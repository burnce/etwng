#!/usr/bin/env ruby

require_relative "../esf_script"
require "csv"

class AnalyzeGovernment < EsfScript
  def load_tsv(path)
    CSV.read("#{__dir__}/data/#{path}", { col_sep: "\t" })
  end

  def trait_level_to_character_trait_table
    unless @trait_level_to_character_trait_table
      @trait_level_to_character_trait_table = {}
      data = load_tsv("character_trait_levels.tsv")
      data[2..-1].each do |ct,ctl,t,tl|
        @trait_level_to_character_trait_table[t] ||= []
        @trait_level_to_character_trait_table[t] << [Integer(tl), Integer(ctl), ct]
      end
    end
    @trait_level_to_character_trait_table
  end

  def trait_level_to_character_trait(trait_str)
    trait, level = trait_str.split("=")
    level = level.to_i
    levels = trait_level_to_character_trait_table[trait] or raise "No such trait #{trait}"
    best_level = levels.select{|tl,ctl,t| level >= tl}.max_by{|tl,ctl,t| ctl}
    if best_level.nil?
      # Might not have enough points to get a trait
      nil
    else
      best_level.last
    end
  end

  def trait_effects
    unless @trait_effects
      @trait_effects = {}
      aa = load_tsv("ancillary_to_attribute_effects.tsv")
      ae = load_tsv("ancillary_to_effects.tsv")
      ta = load_tsv("trait_attribute_effects.tsv")
      te = load_tsv("trait_level_effects.tsv")
      (aa[2..-1] + ae[2..-1] + ta[2..-1] + te[2..-1]).each do |trait, bonus, value|
        @trait_effects[trait] ||= Hash.new(0)
        @trait_effects[trait][bonus] += Integer(value)
      end
    end
    @trait_effects
  end

  def human_government_xml
    each_faction do |faction, faction_name|
      next unless faction_name == human_player
      return faction.xpath("xml_include").map{|node| node['path']}.grep(/\bgovernment\//)[0]
    end
    raise "Cannot find"
  end

  def cleanup_name(name)
    name.sub(/\Anames_name_names_(dutch|polish)/, "")
  end

  def characters
    unless @characters
      @characters = {}
      update_each_xml("character/*.xml", "/rec[@type='CHARACTER_ARRAY']") do |char|
        traits = char.xpath("//rec[@type='CHARACTER_DETAILS']/traits").text.strip.split(/\s+/).map{|t| trait_level_to_character_trait(t)}.compact
        anc = char.xpath("//rec[@type='CHARACTER_DETAILS']/agent_ancillaries").text.strip.split(/\s+/)
        names = char.xpath("//rec[@type='CHARACTER_DETAILS']/loc")[0,2].map(&:text).map{|t| cleanup_name(t)}
        character_id = char.xpath("//rec[@type='CHARACTER_DETAILS']/u")[0].text
        raise "Already exists: #{character_id}" if @characters[character_id]
        @characters[character_id] = {
          anc: anc,
          traits: traits,
          names: names,
        }
        false
      end
    end
    @characters
  end

  def find_minister_ids
    @minister_ids = []
    update_xml(xmldir+"/"+human_government_xml, "/rec[@type='GOVERNMENT']") do |gov|
      @gov_type = gov.xpath("s")[0].text
      gov.xpath("//rec[@type='CHARACTER_POST']").each do |post|
        position = post.xpath("s")[0].text
        characted_id = post.xpath("u")[0].text
        @minister_ids << [position, characted_id]
      end
      false
    end
  end

  def call
    find_minister_ids
    trait_effects

    @minister_ids.each do |pos,i|
      char = characters[i]
      name = char[:names].join(" ")
      bonus = Hash.new(0)

      puts "#{name} - #{pos}"

      (char[:anc] + char[:traits]).each do |t|
        # There is another mwhole level here :-/
        if trait_effects[t]
          trait_effects[t].each do |b,v|
            bonus[b] += v
          end
          # warn "Found bonuses for #{t} - #{trait_effects[t] }"
        else
          warn "Cannot find bonuses for: #{t}"
        end
      end

      bonus.each do |k,v|
        bonus.delete(k) if v == 0
        bonus.delete("happy_character_upper") if @gov_type == "gov_republic"
        bonus.delete("happy_character_middle") if @gov_type == "gov_absolute_monarchy"
        bonus.delete("happy_character_lower") if @gov_type == "gov_constitutional_monarchy"
      end

      p bonus
      puts ""
    end
  end
end

AnalyzeGovernment.new
